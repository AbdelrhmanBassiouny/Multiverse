#!/usr/bin/env python3.10

import json
import argparse
import shutil
import os
import mujoco
from typing import List, Dict
import xml.etree.ElementTree as ET

default_dict = {}
asset_dict = {"mesh": {}}


class Robot:
    def __init__(self):
        self.name = ""
        self.robot_body = ""
        self.path = ""
        self.joint_state = {}
        self.apply = {}
        self.disable_self_collision = "auto"
        self.suffix = {}


def get_body_collision_dict(robot: Robot) -> Dict[str, str]:
    body_collision_dict = {}
    m = mujoco.MjModel.from_xml_path(robot.path)
    d = mujoco.MjData(m)
    mujoco.mj_step(m, d)
    for geom1_id, geom2_id in zip(d.contact.geom1, d.contact.geom2):
        body1_id = m.geom(geom1_id).bodyid[0]
        body1_name = m.body(body1_id).name
        body2_id = m.geom(geom2_id).bodyid[0]
        body2_name = m.body(body2_id).name
        body_collision_dict[body1_name] = body2_name

    return body_collision_dict


def parse_robot(data: str) -> List[Robot]:
    try:
        root = json.loads(data)
    except json.JSONDecodeError as e:
        print(f"Failed to parse {data}: {str(e)}")
        return []

    robots = []
    for robot_name, robot_data in root.items():
        robot = Robot()
        robot.name = robot_name
        robot.path = robot_data.get("path", "")
        robot.apply = robot_data.get("apply", {})
        robot.suffix = robot_data.get("suffix", {"body": "", "joint": "", "geom": ""})
        robot.joint_state = robot_data.get("joint_state", {})
        robot.disable_self_collision = robot_data.get("disable_self_collision", "auto")
        robots.append(robot)

    return robots


def update_element_name(elements: list, element_type: str, suffix: str):
    for element_id, element in enumerate(elements):
        element_name = element.get("name")
        if element_name is None:
            element.set("name", f"{element_type}_{element_id}")
        element.set("name", f"{element_name}{suffix}")


def modify_robot(save_dir_path: str, robot: Robot) -> str:
    print(f"- Name: {robot.name}")
    print(f"  Path: {robot.path}")
    print(f"  Apply: {robot.apply}")

    body_collision_dict = get_body_collision_dict(robot)

    robot_xml_file = robot.name + ".xml"
    robot_xml_path = os.path.join(save_dir_path, robot_xml_file)
    shutil.copy(robot.path, robot_xml_path)

    tree = ET.parse(robot_xml_path)
    root = tree.getroot()
    for compiler_element in root.findall("compiler"):
        if "meshdir" in compiler_element.attrib:
            meshdir = compiler_element.get("meshdir")
            del compiler_element.attrib["meshdir"]
            break

    if robot.disable_self_collision == "auto":
        contact_element = ET.Element("contact")
        root.append(contact_element)
        for body1_name, body2_name in body_collision_dict.items():
            contact_element.append(
                ET.Element(
                    "exclude",
                    {
                        "name": f"{body1_name}_{body2_name}",
                        "body1": body1_name,
                        "body2": body2_name,
                    },
                ),
            )

    for default_element in root.findall("default"):
        for default_child_element in default_element.findall("default"):
            default_dict[default_child_element.get("class")] = list(
                default_child_element
            )
    root.remove(default_element)

    if not os.path.isabs(meshdir):
        meshdir = os.path.join(os.path.dirname(robot.path), meshdir)

    for asset_element in root.findall("asset"):
        for mesh_element in asset_element.findall("mesh"):
            if "file" in mesh_element.attrib:
                file = mesh_element.get("file")
                if not os.path.isabs(file):
                    file = os.path.join(meshdir, file)
                    mesh_element.set("file", file)
            asset_dict["mesh"][mesh_element.get("name")] = mesh_element
    root.remove(asset_element)

    for element_type, element_suffix in robot.suffix.items():
        update_element_name(
            root.findall(f".//{element_type}"), element_type, element_suffix
        )

    body_suffix = robot.suffix["body"]
    for contact_element in root.findall("contact"):
        for exclude_element in contact_element.findall("exclude"):
            body1_name = exclude_element.get("body1")
            body1_name = f"{body1_name}{body_suffix}"
            exclude_element.set("body1", body1_name)
            body2_name = exclude_element.get("body2")
            body2_name = f"{body2_name}{body_suffix}"
            exclude_element.set("body2", f"{body2_name}")
            exclude_element.set("name", f"{body1_name}_{body2_name}")

    for element_type, attributes in robot.apply.items():
        for attribute_name, attribute_props in attributes.items():
            if isinstance(attribute_props, dict):
                for attribute_child_name, attribute_child_prop in attribute_props.items():
                    for element in list(root.iter(element_type)):
                        if element.get("name") == attribute_name:
                            element.set(attribute_child_name, " ".join(map(str, attribute_child_prop)))
            elif isinstance(attribute_props, list):
                for element in list(root.iter(element_type)):
                    element.set(attribute_name, " ".join(map(str, attribute_props)))
            else:
                for element in list(root.iter(element_type)):
                    element.set(attribute_name, f"{attribute_props}")

    ET.indent(tree, space="\t", level=0)
    tree.write(robot_xml_path, encoding="utf-8", xml_declaration=True)
    return robot_xml_path

def get_all_descendants(m, body_id, descendants=None):
    if descendants is None:
        descendants = []
    for i in range(m.nbody):
        if m.body_parentid[i] == body_id:
            descendants.append(i)
            get_all_descendants(m, i, descendants)
    return descendants


def main():
    # Initialize argument parser
    parser = argparse.ArgumentParser(description="Compile MJCF from world and robots.")

    # Define arguments
    parser.add_argument("--name", help="Name of the simulation", required=True)
    parser.add_argument("--world", help="Path to world MJCF", required=True)
    parser.add_argument(
        "--robots", help="JSON string with robots' data", required=False
    )

    # Parse arguments
    args, _ = parser.parse_known_args()

    world_xml_path = args.world
    print(f"World: {world_xml_path}")

    scene_name = args.name

    save_dir_path = os.path.join(
        os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "saved"
    )
    save_dir_path = os.path.join(save_dir_path, scene_name)

    if not os.path.exists(save_dir_path):
        os.makedirs(save_dir_path)

    save_xml_path = os.path.join(save_dir_path, scene_name + ".xml")

    shutil.copy(world_xml_path, save_xml_path)

    if args.robots:
        robots_json_str = args.robots.replace("'", '"')
        robots = parse_robot(robots_json_str)
        print("Robots:")
        for robot in robots:
            robot_xml_file = modify_robot(save_dir_path, robot)

            tree = ET.parse(save_xml_path)
            root = tree.getroot()
            include_element = ET.Element(
                "include", {"file": os.path.basename(robot_xml_file)}
            )
            root.append(include_element)
            tree.write(save_xml_path, encoding="utf-8", xml_declaration=True)

    tree = ET.parse(save_xml_path)
    root = tree.getroot()
    default_parent_element = ET.Element("default")
    root.append(default_parent_element)
    for class_name, default_elements in default_dict.items():
        default_child_element = ET.Element("default", {"class": class_name})
        default_parent_element.append(default_child_element)
        for default_element in default_elements:
            default_child_element.append(default_element)
    asset_element = ET.Element("asset")
    root.append(asset_element)
    for _, mesh_element in asset_dict["mesh"].items():
        asset_element.append(mesh_element)
    tree.write(save_xml_path, encoding="utf-8", xml_declaration=True)

    m = mujoco.MjModel.from_xml_path(save_xml_path)
    if mujoco.mj_name2id(m, mujoco.mjtObj.mjOBJ_BODY, "cursor") == -1:
        tree = ET.parse(save_xml_path)
        root = tree.getroot()
        visual_element = ET.Element("visual")
        root.append(visual_element)
        global_element = ET.Element(
            "global", {"fovy": "45", "azimuth": "225", "elevation": "-30"}
        )
        visual_element.append(global_element)
        worldbody_element = ET.Element("worldbody")
        root.append(worldbody_element)
        body_element = ET.Element(
            "body",
            {"name": "cursor", "mocap": "true", "pos": "0 0 0", "euler": "0 0 0"},
        )
        worldbody_element.append(body_element)
        body_element.append(
            ET.Element(
                "site",
                {
                    "name": "cursor_x",
                    "pos": "0.1 0.0 0.0",
                    "size": "0.01 0.1",
                    "euler": "0.0 1.5708 0.0",
                    "type": "cylinder",
                    "rgba": "1 0 0 0.5",
                },
            )
        )
        body_element.append(
            ET.Element(
                "site",
                {
                    "name": "cursor_y",
                    "pos": "0.0 0.1 0.0",
                    "size": "0.01 0.1",
                    "euler": "1.5708 0.0 0.0",
                    "type": "cylinder",
                    "rgba": "0 1 0 0.5",
                },
            )
        )
        body_element.append(
            ET.Element(
                "site",
                {
                    "name": "cursor_z",
                    "pos": "0.0 0.0 0.1",
                    "size": "0.01 0.1",
                    "euler": "0.0 0.0 0.0",
                    "type": "cylinder",
                    "rgba": "0 0 1 0.5",
                },
            )
        )

        ET.indent(tree, space="\t", level=0)
        tree.write(save_xml_path, encoding="utf-8", xml_declaration=True)

        robot_joints = {}
        for robot in robots:
            robot_joints[robot.name] = {}
            robot_body_id = mujoco.mj_name2id(m, mujoco.mjtObj.mjOBJ_BODY, robot.name)
            for child_body_id in get_all_descendants(m, robot_body_id):
                if m.body_jntnum[child_body_id] == 1:
                    joint_id = m.body_jntadr[child_body_id]
                    joint = m.joint(joint_id)
                    joint_name = joint.name

                    if joint.type[0] == mujoco.mjtJoint.mjJNT_FREE:
                        joint_type = "free"
                    elif joint.type[0] == mujoco.mjtJoint.mjJNT_BALL:
                        joint_type = "ball"
                    elif joint.type[0] == mujoco.mjtJoint.mjJNT_SLIDE:
                        joint_type = "prismatic"
                    elif joint.type[0] == mujoco.mjtJoint.mjJNT_HINGE:
                        joint_type = "revolute"
                    else:
                        joint_type = "unknown"
                    
                    robot_joints[robot.name][joint_name] = joint_type
        robot_joints_str = f"{robot_joints}".replace(" ", "")
        print(f"Robot joints: {robot_joints_str}")

    print(f"Scene: {save_xml_path}", end="")


if __name__ == "__main__":
    main()
